{"version":3,"file":"AccountService.js","sourceRoot":"","sources":["../../src/account/AccountService.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA,6CAAoC;AACpC,oFAA6C;AAC7C,+CAKsB;AACtB,qDAQyB;AACzB,uEAAoE;AAGpE,6DAA0D;AAK1D;;GAEG;AACH,IAAY,YAIX;AAJD,WAAY,YAAY;IACtB,0CAA0B,CAAA;IAC1B,kCAAkB,CAAA;IAClB,gDAAgC,CAAA;AAClC,CAAC,EAJW,YAAY,GAAZ,oBAAY,KAAZ,oBAAY,QAIvB;AA8BD;;GAEG;AACH,IAAY,qBAGX;AAHD,WAAY,qBAAqB;IAC/B,kDAAyB,CAAA;IACzB,sCAAa,CAAA;AACf,CAAC,EAHW,qBAAqB,GAArB,6BAAqB,KAArB,6BAAqB,QAGhC;AACD,IAAY,oBAIX;AAJD,WAAY,oBAAoB;IAC9B,iCAAS,CAAA;IACT,iCAAS,CAAA;IACT,iCAAS,CAAA;AACX,CAAC,EAJW,oBAAoB,GAApB,4BAAoB,KAApB,4BAAoB,QAI/B;AAyBD,MAAa,cAEX,SAAQ,iCAA+C;IAFzD;;QAGW,SAAI,GAAG,gBAAgB,CAAC;QAEzB,UAAK,GAAG,IAAI,mBAAK,EAAE,CAAC;QAE5B,0CAAyB;IAmkB3B,CAAC;IAjkBC,UAAU,CAAC,MAA0C,EAAE,KAA4B;QACjF,uBAAA,IAAI,2BAAY,IAAI,gCAAO,iBAAG,SAAS,EAAE,KAAK,IAAK,MAAM,EAAG,MAAA,CAAC;QAE7D,IAAI,CAAC,YAAY,mCACZ,uBAAA,IAAI,+BAAS,CAAC,KAAK,CAAC,QAAQ,EAAE,KACjC,QAAQ,EAAE,EAAE,GACb,CAAC;QAEF,uBAAA,IAAI,+BAAS,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAM,EAAE,EAAE;YACvC,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;QACtB,CAAC,CAAC,CAAC;QAEH,IAAI,CAAC,UAAU,EAAE,CAAC;IACpB,CAAC;IAED;;;;OAIG;IACG,aAAa;;YACjB,MAAM,cAAc,GAAG,uBAAA,IAAI,+BAAS,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;YACzE,wBAAwB;YACxB,IAAI,CAAC,cAAc,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;aACxC;YACD,MAAM,WAAW,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC;YACtD,MAAM,uBAAA,IAAI,+BAAS,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC;YAClD,MAAM,WAAW,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC;YAEtD,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAE9B,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;YACnC,WAAW,CAAC,OAAO,CAAC,CAAC,eAAuB,EAAE,EAAE;gBAC9C,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,eAAe,CAAC,EAAE;oBAC1C,IAAI,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAC;iBAC1C;YACH,CAAC,CAAC,CAAC;YACH,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3B,CAAC;KAAA;IAED;;;;OAIG;IACG,0BAA0B;;YAC9B,MAAM,cAAc,GAAG,uBAAA,IAAI,+BAAS,CAAC,iBAAiB,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;YACzE,wBAAwB;YACxB,IAAI,CAAC,cAAc,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;aACxC;YACD,MAAM,uBAAA,IAAI,+BAAS,CAAC,aAAa,CAAC,cAAc,CAAC,CAAC;YAClD,MAAM,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC9B,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3B,CAAC;KAAA;IAED,wBAAwB;IAExB;;;;;OAKG;IACG,yBAAyB,CAAC,QAAgB;;YAC9C,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;YAC/C,IAAI;gBACF,MAAM,KAAK,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,yBAAyB,CAAC,QAAQ,CAAC,CAAC;gBACtE,IAAI,CAAC,gBAAgB,CAAC,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC,CAAC;gBACzD,IAAI,CAAC,UAAU,EAAE,CAAC;gBAClB,OAAO,KAAK,CAAC;aACd;oBAAS;gBACR,WAAW,EAAE,CAAC;aACf;QACH,CAAC;KAAA;IAED,gBAAgB,CAAC,SAAmB;;QAClC,MAAM,kBAAkB,GACtB,MAAA,IAAI,CAAC,OAAO,0CAAE,gBAAgB,CAAC,oBAAoB,CAAC,CAAC;QACvD,IAAI,kBAAkB,EAAE;YACtB,kBAAkB,CAAC,gBAAgB,CAAC,SAAS,CAAC,CAAC;SAChD;IACH,CAAC;IAED,kBAAkB,CAAC,eAAuB;;QACxC,MAAM,kBAAkB,GACtB,MAAA,IAAI,CAAC,OAAO,0CAAE,gBAAgB,CAAC,oBAAoB,CAAC,CAAC;QACvD,IAAI,kBAAkB,EAAE;YACtB,kBAAkB,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAC;SACxD;IACH,CAAC;IAED,eAAe,CAAC,OAAe,EAAE,KAAa;;QAC5C,MAAM,kBAAkB,GACtB,MAAA,IAAI,CAAC,OAAO,0CAAE,gBAAgB,CAAC,oBAAoB,CAAC,CAAC;QACvD,IAAI,kBAAkB,EAAE;YACtB,kBAAkB,CAAC,eAAe,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;SACpD;IACH,CAAC;IAED,cAAc,CAAC,OAAe;;QAC5B,MAAM,kBAAkB,GACtB,MAAA,IAAI,CAAC,OAAO,0CAAE,gBAAgB,CAAC,oBAAoB,CAAC,CAAC;QACvD,IAAI,kBAAkB,EAAE;YACtB,kBAAkB,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;SAC5C;IACH,CAAC;IAED,cAAc,CAAC,SAAmB;;QAChC,MAAM,kBAAkB,GACtB,MAAA,IAAI,CAAC,OAAO,0CAAE,gBAAgB,CAAC,oBAAoB,CAAC,CAAC;QACvD,IAAI,kBAAkB,EAAE;YACtB,kBAAkB,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;SAC9C;IACH,CAAC;IAED;;;;;;;;OAQG;IACG,wBAAwB,CAAC,QAAgB,EAAE,IAAuB;;YACtE,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC;YAC/C,IAAI,CAAC,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,EAAE;gBACjC,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;aACrC;YAED,IAAI;gBACF,IAAI,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;gBAC1B,MAAM,KAAK,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,wBAAwB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;gBAC3E,IAAI,CAAC,gBAAgB,CAAC,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC,CAAC;gBACzD,IAAI,CAAC,UAAU,EAAE,CAAC;gBAClB,OAAO,KAAK,CAAC;aACd;oBAAS;gBACR,WAAW,EAAE,CAAC;aACf;QACH,CAAC;KAAA;IAED;;;;;OAKG;IACH,gBAAgB,CAAC,QAAgB;QAC/B,OAAO,uBAAA,IAAI,+BAAS,CAAC,QAAQ,KAAK,QAAQ,CAAC;IAC7C,CAAC;IAED;;;;OAIG;IACH,UAAU;QACR,OAAO,uBAAA,IAAI,+BAAS,CAAC,QAAQ,CAAC,QAAQ,EAAE,CAAC,UAAU,CAAC;IACtD,CAAC;IAED;;;;;OAKG;IACH,gBAAgB,CAAC,QAAgB;QAC/B,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE;YACnC,OAAO,uBAAA,IAAI,+BAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;SAC3C;QACD,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;IACtC,CAAC;IAED;;;;;;OAMG;IACH,aAAa,CAAC,QAAgB,EAAE,OAAe;QAC7C,IAAI,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAAE;YACnC,OAAO,uBAAA,IAAI,+BAAS,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;SAC7C;QACD,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;IACtC,CAAC;IAED;;;;OAIG;IACH,WAAW;QACT,OAAO,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC;IACrC,CAAC;IAED;;;;;;;OAOG;IACG,yBAAyB,CAC7B,QAA+B,EAC/B,IAAW;;YAEX,IAAI,UAAU,CAAC;YACf,QAAQ,QAAQ,EAAE;gBAChB,KAAK,YAAY;oBACf,gDAAgD;oBAChD,MAAM,CAAC,WAAW,CAAC,GAAG,IAAI,CAAC;oBAC3B,IAAI,CAAC,WAAW,EAAE;wBAChB,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;qBAChD;oBACD,gDAAgD;oBAChD,MAAM,QAAQ,GAAG,IAAA,8BAAY,EAAC,WAAW,CAAC,CAAC;oBAE3C,gDAAgD;oBAChD,IAAI,kBAAkB,CAAC;oBACvB,IAAI;wBACF,kBAAkB,GAAG,IAAA,0BAAQ,EAAC,QAAQ,CAAC,CAAC;qBACzC;oBAAC,WAAM;wBACN,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;qBACvD;oBAED,wBAAwB;oBACxB,IAAI,CAAC,IAAA,gCAAc,EAAC,kBAAkB,CAAC,EAAE;wBACvC,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;qBACvD;oBAED,UAAU,GAAG,IAAA,gCAAc,EAAC,QAAQ,CAAC,CAAC;oBACtC,MAAM;gBACR,KAAK,MAAM;oBACT,gDAAgD;oBAChD,IAAI,MAAM,CAAC;oBACX,gDAAgD;oBAChD,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,GAAG,IAAI,CAAC;oBAC/B,IAAI;wBACF,MAAM,GAAG,8BAAS,CAAC,eAAe,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;qBACrD;oBAAC,OAAO,CAAC,EAAE;wBACV,MAAM,GAAG,MAAM,IAAI,CAAC,MAAM,2BAAM,CAAC,MAAM,CAAC,KAAK,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC;qBACjE;oBACD,UAAU,GAAG,IAAA,6BAAW,EAAC,MAAM,CAAC,aAAa,EAAE,CAAC,CAAC;oBACjD,MAAM;gBACR;oBACE,MAAM,IAAI,KAAK,CAAC,gCAAgC,QAAQ,GAAG,CAAC,CAAC;aAChE;YACD,MAAM,UAAU,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,aAAa,CAAC,YAAY,CAAC,MAAM,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;YACxF,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,WAAW,EAAE,CAAC;YAChD,MAAM,WAAW,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC;YACtD,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;YACnC,IAAI,CAAC,kBAAkB,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YACrC,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3B,CAAC;KAAA;IAED;;;;;OAKG;IACG,aAAa,CAAC,OAAe;;YACjC,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;YAC7B,MAAM,uBAAA,IAAI,+BAAS,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAC3C,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3B,CAAC;KAAA;IAED;;;;OAIG;IACH,SAAS;QACP,OAAO,uBAAA,IAAI,+BAAS,CAAC,SAAS,EAAE,CAAC;IACnC,CAAC;IAED;;;;;OAKG;IACH,WAAW,CAAC,aAAoC;QAC9C,OAAO,uBAAA,IAAI,+BAAS,CAAC,WAAW,CAAC,aAAa,CAAC,CAAC;IAClD,CAAC;IAED;;;;;OAKG;IACH,mBAAmB,CAAC,aAAoC;QACtD,OAAO,uBAAA,IAAI,+BAAS,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;IAC1D,CAAC;IAED;;;;;;;OAOG;IACG,gBAAgB,CAAC,aAAiC,EAAE,OAA6B;;YACrF,IAAI;gBACF,MAAM,OAAO,GAAG,IAAA,wBAAgB,EAAC,aAAa,CAAC,IAAI,CAAC,CAAC;gBACrD,MAAM,SAAS,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBACjD,MAAM,UAAU,GAAG,MAAM,SAAS,CAAC,WAAW,EAAE,CAAC;gBACjD,IACE,UAAU,CAAC,SAAS,CAClB,CAAC,SAAiB,EAAE,EAAE,CAAC,SAAS,CAAC,WAAW,EAAE,KAAK,OAAO,CAAC,WAAW,EAAE,CACzE,KAAK,CAAC,CAAC,EACR;oBACA,MAAM,kBAAkB,qBAAQ,aAAa,CAAE,CAAC;oBAChD,IAAI,OAAO,KAAK,oBAAoB,CAAC,EAAE,IAAI,OAAO,kBAAkB,CAAC,IAAI,KAAK,QAAQ,EAAE;wBACtF,kBAAkB,CAAC,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;qBAC/D;oBACD,OAAO,uBAAA,IAAI,+BAAS,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,EAAE,OAAO,EAAE,CAAC,CAAC;iBACxE;gBAED,MAAM,EAAE,QAAQ,EAAE,GAAG,uBAAA,IAAI,+BAAS,CAAC;gBACnC,MAAM,UAAU,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;gBAC/D,MAAM,gBAAgB,GAAG,IAAA,0BAAQ,EAAC,IAAA,8BAAY,EAAC,UAAU,CAAC,CAAC,CAAC;gBAC5D,QAAQ,OAAO,EAAE;oBACf,KAAK,oBAAoB,CAAC,EAAE;wBAC1B,yDAAyD;wBACzD,OAAO,IAAA,kCAAmB,EAAC,gBAAgB,EAAE;4BAC3C,IAAI,EAAE,aAAa,CAAC,IAAW;yBAChC,CAAC,CAAC;oBACL,KAAK,oBAAoB,CAAC,EAAE;wBAC1B,OAAO,IAAA,4BAAa,EAAC,gBAAgB,EAAE;4BACrC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAc,CAAC;yBAC/C,CAAC,CAAC;oBACL,KAAK,oBAAoB,CAAC,EAAE;wBAC1B,OAAO,IAAA,+BAAe,EAAC,gBAAgB,EAAE;4BACvC,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,aAAa,CAAC,IAAc,CAAC;yBAC/C,CAAC,CAAC;oBACL;wBACE,MAAM,IAAI,KAAK,CAAC,yCAAyC,OAAO,GAAG,CAAC,CAAC;iBACxE;aACF;YAAC,OAAO,KAAK,EAAE;gBACd,MAAM,IAAI,KAAK,CAAC,wCAAwC,KAAK,EAAE,CAAC,CAAC;aAClE;QACH,CAAC;KAAA;IAED;;;;;;OAMG;IACH,eAAe,CAAC,WAAoB,EAAE,IAAY;QAChD,OAAO,uBAAA,IAAI,+BAAS,CAAC,eAAe,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;IAC1D,CAAC;IAED;;;;;OAKG;IACG,cAAc,CAAC,QAAgB;;YACnC,MAAM,uBAAA,IAAI,+BAAS,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;YAC7C,MAAM,QAAQ,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC;YACnD,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC;YACpC,OAAO,IAAI,CAAC,UAAU,EAAE,CAAC;QAC3B,CAAC;KAAA;IAED;;;;;OAKG;IACH,MAAM,CAAC,QAAoB;QACzB,OAAO,uBAAA,IAAI,+BAAS,CAAC,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAC5C,CAAC;IAED;;;;;OAKG;IACH,QAAQ,CAAC,QAAoB;QAC3B,OAAO,uBAAA,IAAI,+BAAS,CAAC,EAAE,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;IAC9C,CAAC;IAED;;;;OAIG;IACG,gBAAgB;;YACpB,MAAM,cAAc,GAAG,uBAAA,IAAI,+BAAS,CAAC,iBAAiB,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YAC3E,wBAAwB;YACxB,IAAI,CAAC,cAAc,EAAE;gBACnB,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;aACzC;YAED,MAAM,SAAS,GAAG,CAAC,MAAM,cAAc,CAAC,SAAS,EAAE,CAAC,CAAC,QAAQ,CAAC;YAC9D,MAAM,QAAQ,GAAG,MAAM,cAAc,CAAC,WAAW,EAAE,CAAC;YACpD,wBAAwB;YACxB,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;gBACzB,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;aACpD;YAED,MAAM,gBAAgB,GAAG,uBAAA,IAAI,+BAAS,CAAC,sBAAsB,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;YAC/E,MAAM,WAAW,GAAG,IAAI,gBAAgB,CAAC;gBACvC,QAAQ,EAAE,SAAS;gBACnB,gBAAgB,EAAE,QAAQ,CAAC,MAAM;aAClC,CAAC,CAAC;YACH,MAAM,YAAY,GAAG,MAAM,WAAW,CAAC,WAAW,EAAE,CAAC;YACrD,wBAAwB;YACxB,IAAI,YAAY,CAAC,MAAM,KAAK,QAAQ,CAAC,MAAM,EAAE;gBAC3C,MAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;aACvE;YAED,YAAY,CAAC,OAAO,CAAC,CAAC,OAAe,EAAE,CAAS,EAAE,EAAE;gBAClD,wBAAwB;gBACxB,IAAI,OAAO,CAAC,WAAW,EAAE,KAAK,QAAQ,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,EAAE;oBACvD,MAAM,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC;iBAC7D;YACH,CAAC,CAAC,CAAC;YAEH,OAAO,SAAS,CAAC;QACnB,CAAC;KAAA;IAED;;;;OAIG;IACG,UAAU;;YACd,MAAM,QAAQ,GAAkB,MAAM,OAAO,CAAC,GAAG,CAC/C,uBAAA,IAAI,+BAAS,CAAC,QAAQ,CAAC,GAAG,CACxB,CAAO,OAAsB,EAAE,KAAa,EAAwB,EAAE;gBACpE,MAAM,eAAe,GAAG,MAAM,OAAO,CAAC,WAAW,EAAE,CAAC;gBACpD,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC;oBAC7C,CAAC,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,IAAI,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC;oBACtE,CAAC,CAAC,0BAA0B,CAAC,EAAE,CAAC;gBAClC,OAAO;oBACL,QAAQ;oBACR,KAAK;oBACL,IAAI,EAAE,OAAO,CAAC,IAAI;iBACnB,CAAC;YACJ,CAAC,CAAA,CACF,CACF,CAAC;YACF,IAAI,CAAC,WAAW,CAAC,EAAE,QAAQ,EAAE,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;YAC9C,OAAO,uBAAA,IAAI,+BAAS,CAAC,UAAU,EAAE,CAAC;QACpC,CAAC;KAAA;IAED;;;;OAIG;IACW,YAAY;;YACxB,MAAM,OAAO,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,aAAa,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC;YACnE,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;YACxB,OAAO,OAAO,CAAC;QACjB,CAAC;KAAA;IAED;;;;OAIG;IACG,iBAAiB;;YACrB,MAAM,OAAO,GAAG,uBAAA,IAAI,+BAAS,CAAC,iBAAiB,CAAC,YAAY,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;YACpE,OAAO,OAAO,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;QACxC,CAAC;KAAA;IAEK,gBAAgB,CAAC,UAAe;;YACpC,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;YACzD,IAAI,CAAC,gBAAgB,CAAC,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC,CAAC;YACzD,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;QAC1B,CAAC;KAAA;IAEK,mBAAmB;;YACvB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,UAAU,EAAE,CAAC;QAChD,CAAC;KAAA;IAEK,iBAAiB;;YACrB,OAAO,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,WAAW,EAAE,CAAC;QACxD,CAAC;KAAA;IAEK,mBAAmB,CAAC,WAAmB;;YAC3C,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,iBAAiB,CAAC,WAAW,CAAC,CAAC;QAClE,CAAC;KAAA;IAEK,qBAAqB,CAAC,aAAqB;;YAC/C,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC;QACtE,CAAC;KAAA;IAEK,iBAAiB,CAAC,SAAiB,EAAE,YAAoB;;YAC7D,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,eAAe,CAAC,SAAS,EAAE,YAAY,CAAC,CAAC;QAC5E,CAAC;KAAA;IAEK,mBAAmB;;YACvB,CAAC,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC,CAAC,iBAAiB,EAAE,CAAC;QACvD,CAAC;KAAA;IAEK,iBAAiB,CACrB,IAAY;;YAEZ,IAAI;gBACF,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;gBAC/C,IAAI,QAAQ,CAAC;gBACb,QAAQ,IAAI,EAAE;oBACZ,KAAK,CAAC,CAAC;wBACL,QAAQ,GAAG,MAAM,OAAO,CAAC,eAAe,EAAE,CAAC;wBAC3C,MAAM;oBACR,KAAK,CAAC;wBACJ,QAAQ,GAAG,MAAM,OAAO,CAAC,WAAW,EAAE,CAAC;wBACvC,MAAM;oBACR;wBACE,QAAQ,GAAG,MAAM,OAAO,CAAC,YAAY,EAAE,CAAC;iBAC3C;gBACD,OAAO,QAAQ,CAAC,GAAG,CAAC,CAAC,OAAY,EAAE,EAAE,CAAC,iCACjC,OAAO,KACV,OAAO,EAAE,KAAK,IACd,CAAC,CAAC;aACL;YAAC,OAAO,CAAC,EAAE;gBACV,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,EAAE,CAAC,CAAC;aACrE;QACH,CAAC;KAAA;IAEK,6BAA6B,CAAC,KAAa;;YAC/C,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAE/C,OAAO,CAAC,kBAAkB,CAAC,KAAK,CAAC,CAAC;YAClC,MAAM,WAAW,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC;YACtD,MAAM,uBAAA,IAAI,+BAAS,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;YAC3C,MAAM,WAAW,GAAG,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAC;YACtD,IAAI,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC;YACnC,WAAW,CAAC,OAAO,CAAC,CAAC,OAAe,EAAE,EAAE;gBACtC,IAAI,CAAC,WAAW,CAAC,QAAQ,CAAC,OAAO,CAAC,EAAE;oBAClC,IAAI,IAAI,CAAC,eAAe,EAAE;wBACxB,IAAI,CAAC,eAAe,CAAC,OAAO,EAAE,GAAG,OAAO,CAAC,OAAO,EAAE,IAAI,KAAK,EAAE,CAAC,CAAC;qBAChE;oBACD,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;iBAClC;YACH,CAAC,CAAC,CAAC;YACH,MAAM,uBAAA,IAAI,+BAAS,CAAC,kBAAkB,EAAE,CAAC;YACzC,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;QAC1B,CAAC;KAAA;IAEK,qBAAqB,CAAC,OAAe;;YACzC,OAAO,CAAC,MAAM,uBAAA,IAAI,+BAAS,CAAC,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC;QAClE,CAAC;KAAA;IAEK,cAAc;;YAClB,MAAM,OAAO,GAAG,MAAM,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAC/C,OAAO,CAAC,YAAY,EAAE,CAAC;YACvB,MAAM,QAAQ,GAAG,CAAC,MAAM,uBAAA,IAAI,+BAAS,CAAC,WAAW,EAAE,CAAa,CAAC;YACjE,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gBAC3B,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC;YACnC,CAAC,CAAC,CAAC;YACH,MAAM,uBAAA,IAAI,+BAAS,CAAC,kBAAkB,EAAE,CAAC;YACzC,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;QAC1B,CAAC;KAAA;IAED,oBAAoB,CAAC,OAAe;QAClC,MAAM,WAAW,GAAG,IAAA,8BAAY,EAAC,OAAO,CAAC,CAAC;QAC1C,IAAI,CAAC,IAAA,6BAAW,EAAC,WAAW,CAAC,EAAE;YAC7B,OAAO,WAAW,CAAC;SACpB;QACD,OAAO,IAAA,mCAAiB,EAAC,WAAW,CAAC,CAAC;IACxC,CAAC;CACF;AA1kBD,wCA0kBC;;AACD,kBAAe,cAAc,CAAC","sourcesContent":["import {\n  IKeyringState as IQRKeyringState,\n  MetaMaskKeyring as QRKeyring,\n} from '@keystonehq/metamask-airgapped-keyring';\nimport { Mutex } from 'async-mutex';\nimport Keyring from 'eth-keyring-controller';\nimport {\n  normalize as normalizeAddress,\n  signTypedData,\n  signTypedDataLegacy,\n  signTypedData_v4 as signTypedDataV4,\n} from 'eth-sig-util';\nimport {\n  addHexPrefix,\n  bufferToHex,\n  isHexString,\n  isValidPrivate,\n  stripHexPrefix,\n  toBuffer,\n  toChecksumAddress,\n} from 'ethereumjs-util';\nimport Wallet, { thirdparty as importers } from 'ethereumjs-wallet';\n\nimport { IConfig, IState } from '../core/AbstractAdapter';\nimport { AbstractService } from '../core/AbstractService';\nimport { PreferencesService } from '../user/PreferencesService';\nimport { AbstractAccountAdapter } from './AbstractAccountAdapter';\nimport { PersonalMessageParams, TypedMessageParams } from './MessageType';\n\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n  simple = 'Simple Key Pair',\n  hd = 'HD Key Tree',\n  qr = 'QR Hardware Wallet Device',\n}\n\n/**\n * @type KeyringObject\n *\n * Keyring object\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @function getAccounts - Get associated accounts\n */\nexport interface KeyringObject {\n  type: string;\n  accounts: string[];\n  getAccounts(): string[];\n}\n\n/**\n * @type KeyringBase\n *\n * KeyringBase object to return in fullUpdate\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @property index - Associated index\n */\nexport interface KeyringBase {\n  accounts: string[];\n  type: string;\n  index?: number;\n}\n\n/**\n * A strategy for importing an account\n */\nexport enum AccountImportStrategy {\n  privateKey = 'privateKey',\n  json = 'json',\n}\nexport enum SignTypedDataVersion {\n  V1 = 'V1',\n  V3 = 'V3',\n  V4 = 'V4',\n}\n/**\n * @type KeyringMemState\n *\n * Keyring mem controller state\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n */\nexport interface KeyringMemState extends IState {\n  isUnlocked: boolean;\n  keyringTypes: string[];\n  keyrings: KeyringBase[];\n}\n\nexport interface AccountState extends IState {\n  vault?: string;\n  keyrings: KeyringBase[];\n}\n\nexport interface AccountConfig extends IConfig {\n  encryptor?: any;\n  keyringTypes?: any[];\n}\n\nexport class AccountService<\n  A extends AbstractAccountAdapter<AccountState, AccountConfig>\n> extends AbstractService<A, AccountState, AccountConfig> {\n  override name = 'AccountService';\n\n  private mutex = new Mutex();\n\n  #keyring: typeof Keyring;\n\n  initialize(config: Partial<AccountConfig> | undefined, state: Partial<AccountState>): void {\n    this.#keyring = new Keyring({ initState: state, ...config });\n\n    this.defaultState = {\n      ...this.#keyring.store.getState(),\n      keyrings: [],\n    };\n\n    this.#keyring.store.subscribe((s: any) => {\n      this.updateState(s);\n    });\n\n    this.fullUpdate();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring.\n   *\n   * @returns Promise resolving to current state when the account is added.\n   */\n  async addNewAccount(): Promise<KeyringMemState> {\n    const primaryKeyring = this.#keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    const oldAccounts = await this.#keyring.getAccounts();\n    await this.#keyring.addNewAccount(primaryKeyring);\n    const newAccounts = await this.#keyring.getAccounts();\n\n    await this.verifySeedPhrase();\n\n    this.updateIdentities(newAccounts);\n    newAccounts.forEach((selectedAddress: string) => {\n      if (!oldAccounts.includes(selectedAddress)) {\n        this.setSelectedAddress(selectedAddress);\n      }\n    });\n    return this.fullUpdate();\n  }\n\n  /**\n   * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.\n   *\n   * @returns Promise resolving to current state when the account is added.\n   */\n  async addNewAccountWithoutUpdate(): Promise<KeyringMemState> {\n    const primaryKeyring = this.#keyring.getKeyringsByType('HD Key Tree')[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found');\n    }\n    await this.#keyring.addNewAccount(primaryKeyring);\n    await this.verifySeedPhrase();\n    return this.fullUpdate();\n  }\n\n  // update(state: any) {}\n\n  /**\n   * Create a new primary keychain and wipe any previous keychains.\n   *\n   * @param password - Password to unlock the new vault.\n   * @returns Newly-created keychain object.\n   */\n  async createNewVaultAndKeychain(password: string) {\n    const releaseLock = await this.mutex.acquire();\n    try {\n      const vault = await this.#keyring.createNewVaultAndKeychain(password);\n      this.updateIdentities(await this.#keyring.getAccounts());\n      this.fullUpdate();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  updateIdentities(addresses: string[]) {\n    const preferencesService: PreferencesService<any> | undefined =\n      this.manager?.getServiceByName('PreferencesService');\n    if (preferencesService) {\n      preferencesService.updateIdentities(addresses);\n    }\n  }\n\n  setSelectedAddress(selectedAddress: string) {\n    const preferencesService: PreferencesService<any> | undefined =\n      this.manager?.getServiceByName('PreferencesService');\n    if (preferencesService) {\n      preferencesService.setSelectedAddress(selectedAddress);\n    }\n  }\n\n  setAccountLabel(address: string, label: string) {\n    const preferencesService: PreferencesService<any> | undefined =\n      this.manager?.getServiceByName('PreferencesService');\n    if (preferencesService) {\n      preferencesService.setAccountLabel(address, label);\n    }\n  }\n\n  removeIdentity(address: string) {\n    const preferencesService: PreferencesService<any> | undefined =\n      this.manager?.getServiceByName('PreferencesService');\n    if (preferencesService) {\n      preferencesService.removeIdentity(address);\n    }\n  }\n\n  syncIdentities(addresses: string[]) {\n    const preferencesService: PreferencesService<any> | undefined =\n      this.manager?.getServiceByName('PreferencesService');\n    if (preferencesService) {\n      preferencesService.syncIdentities(addresses);\n    }\n  }\n\n  /**\n   * Effectively the same as creating a new keychain then populating it\n   * using the given seed phrase.\n   *\n   * @param password - Password to unlock keychain.\n   * @param seed - A BIP39-compliant seed phrase,\n   * either as a string or an array of UTF-8 bytes that represent the string.\n   * @returns Promise resolving to the restored keychain object.\n   */\n  async createNewVaultAndRestore(password: string, seed: string | number[]) {\n    const releaseLock = await this.mutex.acquire();\n    if (!password || !password.length) {\n      throw new Error('Invalid password');\n    }\n\n    try {\n      this.updateIdentities([]);\n      const vault = await this.#keyring.createNewVaultAndRestore(password, seed);\n      this.updateIdentities(await this.#keyring.getAccounts());\n      this.fullUpdate();\n      return vault;\n    } finally {\n      releaseLock();\n    }\n  }\n\n  /**\n   * Method to validate a password against the password from the keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Boolean indicating if input password is valid\n   */\n  validatePassword(password: string): boolean {\n    return this.#keyring.password === password;\n  }\n\n  /**\n   * Returns the status of the vault.\n   *\n   * @returns Boolean returning true if the vault is unlocked.\n   */\n  isUnlocked(): boolean {\n    return this.#keyring.memStore.getState().isUnlocked;\n  }\n\n  /**\n   * Gets the seed phrase of the HD keyring.\n   *\n   * @param password - Password of the keyring.\n   * @returns Promise resolving to the seed phrase.\n   */\n  exportSeedPhrase(password: string) {\n    if (this.validatePassword(password)) {\n      return this.#keyring.keyrings[0].mnemonic;\n    }\n    throw new Error('Invalid password');\n  }\n\n  /**\n   * Gets the private key from the keyring controlling an address.\n   *\n   * @param password - Password of the keyring.\n   * @param address - Address to export.\n   * @returns Promise resolving to the private key for an address.\n   */\n  exportAccount(password: string, address: string): Promise<string> {\n    if (this.validatePassword(password)) {\n      return this.#keyring.exportAccount(address);\n    }\n    throw new Error('Invalid password');\n  }\n\n  /**\n   * Returns the public addresses of all accounts for the current keyring.\n   *\n   * @returns A promise resolving to an array of addresses.\n   */\n  getAccounts(): Promise<string[]> {\n    return this.#keyring.getAccounts();\n  }\n\n  /**\n   * Imports an account with the specified import strategy.\n   *\n   * @param strategy - Import strategy name.\n   * @param args - Array of arguments to pass to the underlying stategy.\n   * @throws Will throw when passed an unrecognized strategy.\n   * @returns Promise resolving to current state when the import is complete.\n   */\n  async importAccountWithStrategy(\n    strategy: AccountImportStrategy,\n    args: any[]\n  ): Promise<KeyringMemState> {\n    let privateKey;\n    switch (strategy) {\n      case 'privateKey':\n        // eslint-disable-next-line no-case-declarations\n        const [importedKey] = args;\n        if (!importedKey) {\n          throw new Error('Cannot import an empty key.');\n        }\n        // eslint-disable-next-line no-case-declarations\n        const prefixed = addHexPrefix(importedKey);\n\n        // eslint-disable-next-line no-case-declarations\n        let bufferedPrivateKey;\n        try {\n          bufferedPrivateKey = toBuffer(prefixed);\n        } catch {\n          throw new Error('Cannot import invalid private key.');\n        }\n\n        /* istanbul ignore if */\n        if (!isValidPrivate(bufferedPrivateKey)) {\n          throw new Error('Cannot import invalid private key.');\n        }\n\n        privateKey = stripHexPrefix(prefixed);\n        break;\n      case 'json':\n        // eslint-disable-next-line no-case-declarations\n        let wallet;\n        // eslint-disable-next-line no-case-declarations\n        const [input, password] = args;\n        try {\n          wallet = importers.fromEtherWallet(input, password);\n        } catch (e) {\n          wallet = wallet || (await Wallet.fromV3(input, password, true));\n        }\n        privateKey = bufferToHex(wallet.getPrivateKey());\n        break;\n      default:\n        throw new Error(`Unexpected import strategy: '${strategy}'`);\n    }\n    const newKeyring = await this.#keyring.addNewKeyring(KeyringTypes.simple, [privateKey]);\n    const accounts = await newKeyring.getAccounts();\n    const allAccounts = await this.#keyring.getAccounts();\n    this.updateIdentities(allAccounts);\n    this.setSelectedAddress(accounts[0]);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Removes an account from keyring state.\n   *\n   * @param address - Address of the account to remove.\n   * @returns Promise resolving current state when this account removal completes.\n   */\n  async removeAccount(address: string): Promise<KeyringMemState> {\n    this.removeIdentity(address);\n    await this.#keyring.removeAccount(address);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Deallocates all secrets and locks the wallet.\n   *\n   * @returns Promise resolving to current state.\n   */\n  setLocked(): Promise<KeyringMemState> {\n    return this.#keyring.setLocked();\n  }\n\n  /**\n   * Signs message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  signMessage(messageParams: PersonalMessageParams) {\n    return this.#keyring.signMessage(messageParams);\n  }\n\n  /**\n   * Signs personal message by calling down into a specific keyring.\n   *\n   * @param messageParams - PersonalMessageParams object to sign.\n   * @returns Promise resolving to a signed message string.\n   */\n  signPersonalMessage(messageParams: PersonalMessageParams) {\n    return this.#keyring.signPersonalMessage(messageParams);\n  }\n\n  /**\n   * Signs typed message by calling down into a specific keyring.\n   *\n   * @param messageParams - TypedMessageParams object to sign.\n   * @param version - Compatibility version EIP712.\n   * @throws Will throw when passed an unrecognized version.\n   * @returns Promise resolving to a signed message string or an error if any.\n   */\n  async signTypedMessage(messageParams: TypedMessageParams, version: SignTypedDataVersion) {\n    try {\n      const address = normalizeAddress(messageParams.from);\n      const qrKeyring = await this.getOrAddQRKeyring();\n      const qrAccounts = await qrKeyring.getAccounts();\n      if (\n        qrAccounts.findIndex(\n          (qrAddress: string) => qrAddress.toLowerCase() === address.toLowerCase()\n        ) !== -1\n      ) {\n        const messageParamsClone = { ...messageParams };\n        if (version !== SignTypedDataVersion.V1 && typeof messageParamsClone.data === 'string') {\n          messageParamsClone.data = JSON.parse(messageParamsClone.data);\n        }\n        return this.#keyring.signTypedMessage(messageParamsClone, { version });\n      }\n\n      const { password } = this.#keyring;\n      const privateKey = await this.exportAccount(password, address);\n      const privateKeyBuffer = toBuffer(addHexPrefix(privateKey));\n      switch (version) {\n        case SignTypedDataVersion.V1:\n          // signTypedDataLegacy will throw if the data is invalid.\n          return signTypedDataLegacy(privateKeyBuffer, {\n            data: messageParams.data as any,\n          });\n        case SignTypedDataVersion.V3:\n          return signTypedData(privateKeyBuffer, {\n            data: JSON.parse(messageParams.data as string),\n          });\n        case SignTypedDataVersion.V4:\n          return signTypedDataV4(privateKeyBuffer, {\n            data: JSON.parse(messageParams.data as string),\n          });\n        default:\n          throw new Error(`Unexpected signTypedMessage version: '${version}'`);\n      }\n    } catch (error) {\n      throw new Error(`Keyring Controller signTypedMessage: ${error}`);\n    }\n  }\n\n  /**\n   * Signs a transaction by calling down into a specific keyring.\n   *\n   * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.\n   * @param from - Address to sign from, should be in keychain.\n   * @returns Promise resolving to a signed transaction string.\n   */\n  signTransaction(transaction: unknown, from: string) {\n    return this.#keyring.signTransaction(transaction, from);\n  }\n\n  /**\n   * Attempts to decrypt the current vault and load its keyrings.\n   *\n   * @param password - Password to unlock the keychain.\n   * @returns Promise resolving to the current state.\n   */\n  async submitPassword(password: string): Promise<KeyringMemState> {\n    await this.#keyring.submitPassword(password);\n    const accounts = await this.#keyring.getAccounts();\n    await this.syncIdentities(accounts);\n    return this.fullUpdate();\n  }\n\n  /**\n   * Adds new listener to be notified when the wallet is locked.\n   *\n   * @param listener - Callback triggered when wallet is locked.\n   * @returns EventEmitter if listener added.\n   */\n  onLock(listener: () => void) {\n    return this.#keyring.on('lock', listener);\n  }\n\n  /**\n   * Adds new listener to be notified when the wallet is unlocked.\n   *\n   * @param listener - Callback triggered when wallet is unlocked.\n   * @returns EventEmitter if listener added.\n   */\n  onUnlock(listener: () => void) {\n    return this.#keyring.on('unlock', listener);\n  }\n\n  /**\n   * Verifies the that the seed phrase restores the current keychain's accounts.\n   *\n   * @returns Whether the verification succeeds.\n   */\n  async verifySeedPhrase(): Promise<string> {\n    const primaryKeyring = this.#keyring.getKeyringsByType(KeyringTypes.hd)[0];\n    /* istanbul ignore if */\n    if (!primaryKeyring) {\n      throw new Error('No HD keyring found.');\n    }\n\n    const seedWords = (await primaryKeyring.serialize()).mnemonic;\n    const accounts = await primaryKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (accounts.length === 0) {\n      throw new Error('Cannot verify an empty keyring.');\n    }\n\n    const TestKeyringClass = this.#keyring.getKeyringClassForType(KeyringTypes.hd);\n    const testKeyring = new TestKeyringClass({\n      mnemonic: seedWords,\n      numberOfAccounts: accounts.length,\n    });\n    const testAccounts = await testKeyring.getAccounts();\n    /* istanbul ignore if */\n    if (testAccounts.length !== accounts.length) {\n      throw new Error('Seed phrase imported incorrect number of accounts.');\n    }\n\n    testAccounts.forEach((account: string, i: number) => {\n      /* istanbul ignore if */\n      if (account.toLowerCase() !== accounts[i].toLowerCase()) {\n        throw new Error('Seed phrase imported different accounts.');\n      }\n    });\n\n    return seedWords;\n  }\n\n  /**\n   * Update keyrings in state and calls KeyringController fullUpdate method returning current state.\n   *\n   * @returns The current state.\n   */\n  async fullUpdate(): Promise<KeyringMemState> {\n    const keyrings: KeyringBase[] = await Promise.all<KeyringBase>(\n      this.#keyring.keyrings.map(\n        async (keyring: KeyringObject, index: number): Promise<KeyringBase> => {\n          const keyringAccounts = await keyring.getAccounts();\n          const accounts = Array.isArray(keyringAccounts)\n            ? keyringAccounts.map((address) => this.toChecksumHexAddress(address))\n            : /* istanbul ignore next */ [];\n          return {\n            accounts,\n            index,\n            type: keyring.type,\n          };\n        }\n      )\n    );\n    this.updateState({ keyrings: [...keyrings] });\n    return this.#keyring.fullUpdate();\n  }\n\n  /**\n   * Add qr hardware keyring.\n   *\n   * @returns The added keyring\n   */\n  private async addQRKeyring(): Promise<QRKeyring> {\n    const keyring = await this.#keyring.addNewKeyring(KeyringTypes.qr);\n    await this.fullUpdate();\n    return keyring;\n  }\n\n  /**\n   * Get qr hardware keyring.\n   *\n   * @returns The added keyring\n   */\n  async getOrAddQRKeyring(): Promise<QRKeyring> {\n    const keyring = this.#keyring.getKeyringsByType(KeyringTypes.qr)[0];\n    return keyring || this.addQRKeyring();\n  }\n\n  async restoreQRKeyring(serialized: any): Promise<void> {\n    (await this.getOrAddQRKeyring()).deserialize(serialized);\n    this.updateIdentities(await this.#keyring.getAccounts());\n    await this.fullUpdate();\n  }\n\n  async resetQRKeyringState(): Promise<void> {\n    (await this.getOrAddQRKeyring()).resetStore();\n  }\n\n  async getQRKeyringState(): Promise<IQRKeyringState> {\n    return (await this.getOrAddQRKeyring()).getMemStore();\n  }\n\n  async submitQRCryptoHDKey(cryptoHDKey: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);\n  }\n\n  async submitQRCryptoAccount(cryptoAccount: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);\n  }\n\n  async submitQRSignature(requestId: string, ethSignature: string): Promise<void> {\n    (await this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);\n  }\n\n  async cancelQRSignRequest(): Promise<void> {\n    (await this.getOrAddQRKeyring()).cancelSignRequest();\n  }\n\n  async connectQRHardware(\n    page: number\n  ): Promise<{ balance: string; address: string; index: number }[]> {\n    try {\n      const keyring = await this.getOrAddQRKeyring();\n      let accounts;\n      switch (page) {\n        case -1:\n          accounts = await keyring.getPreviousPage();\n          break;\n        case 1:\n          accounts = await keyring.getNextPage();\n          break;\n        default:\n          accounts = await keyring.getFirstPage();\n      }\n      return accounts.map((account: any) => ({\n        ...account,\n        balance: '0x0',\n      }));\n    } catch (e) {\n      throw new Error(`Unspecified error when connect QR Hardware, ${e}`);\n    }\n  }\n\n  async unlockQRHardwareWalletAccount(index: number): Promise<void> {\n    const keyring = await this.getOrAddQRKeyring();\n\n    keyring.setAccountToUnlock(index);\n    const oldAccounts = await this.#keyring.getAccounts();\n    await this.#keyring.addNewAccount(keyring);\n    const newAccounts = await this.#keyring.getAccounts();\n    this.updateIdentities(newAccounts);\n    newAccounts.forEach((address: string) => {\n      if (!oldAccounts.includes(address)) {\n        if (this.setAccountLabel) {\n          this.setAccountLabel(address, `${keyring.getName()} ${index}`);\n        }\n        this.setSelectedAddress(address);\n      }\n    });\n    await this.#keyring.persistAllKeyrings();\n    await this.fullUpdate();\n  }\n\n  async getAccountKeyringType(account: string): Promise<KeyringTypes> {\n    return (await this.#keyring.getKeyringForAccount(account)).type;\n  }\n\n  async forgetQRDevice(): Promise<void> {\n    const keyring = await this.getOrAddQRKeyring();\n    keyring.forgetDevice();\n    const accounts = (await this.#keyring.getAccounts()) as string[];\n    accounts.forEach((account) => {\n      this.setSelectedAddress(account);\n    });\n    await this.#keyring.persistAllKeyrings();\n    await this.fullUpdate();\n  }\n\n  toChecksumHexAddress(address: string) {\n    const hexPrefixed = addHexPrefix(address);\n    if (!isHexString(hexPrefixed)) {\n      return hexPrefixed;\n    }\n    return toChecksumAddress(hexPrefixed);\n  }\n}\nexport default AccountService;\n"]}