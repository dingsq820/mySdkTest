{"version":3,"file":"TransactionService.js","sourceRoot":"","sources":["../../src/transaction/TransactionService.ts"],"names":[],"mappings":"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","sourcesContent":["import fetch, { RequestInit } from 'node-fetch';\n\nimport { AbstractAdapter, IConfig, IState } from '../core/AbstractAdapter';\nimport { AbstractService } from '../core/AbstractService';\n\nexport const POLYGON = 'polygon';\n\n/**\n * @type Fetch All Options\n * @property fromBlock - String containing a specific block decimal number\n * @property etherscanApiKey - API key to be used to fetch token transactions\n */\nexport interface FetchNftAllOptions {\n  fromBlockNum?: string;\n  apiKey?: string;\n}\n\n/**\n * @type Transaction\n *\n * Transaction representation\n * @property from - Address to send this transaction from\n * @property to - Address to send this transaction to\n * @property status - String status of this transaction\n * @property time - Timestamp associated with this transaction\n * @property transaction - Underlying Transaction object\n * @property transactionHash - Hash of a successful transaction\n * @property blockNumber - Number of the block where the transaction has been included\n */\nexport interface TransactionData {\n  chainId?: string;\n  from: string;\n  to?: string;\n  status: 'confirmed';\n  time: number;\n  transactionHash?: string;\n  blockNumber?: string;\n}\n\n/**\n * @type PolygonScanTransaction\n *\n * PolygonScanTransaction representation\n * @property blockNumber - Number of the block where the transaction has been included\n * @property timeStamp - Timestamp associated with this transaction\n * @property hash - Hash of a successful transaction\n * @property nonce - Nonce of the transaction\n * @property blockHash - Hash of the block where the transaction has been included\n * @property transactionIndex - Etherscan internal index for this transaction\n * @property from - Address to send this transaction from\n * @property to - Address to send this transaction to\n * @property gas - Gas to send with this transaction\n * @property gasPrice - Price of gas with this transaction\n * @property isError - Synthesized error information for failed transactions\n * @property txreceipt_status - Receipt status for this transaction\n * @property input - input of the transaction\n * @property contractAddress - Address of the contract\n * @property cumulativeGasUsed - Amount of gas used\n * @property confirmations - Number of confirmations\n * @property tokenID - ID of token\n * @property tokenName - Name of token\n */\nexport interface PolygonScanTransaction {\n  blockNumber: string;\n  timeStamp: string;\n  hash: string;\n  nonce: string;\n  blockHash: string;\n  transactionIndex: string;\n  from: string;\n  to: string;\n  value: string;\n  gas: string;\n  gasPrice: string;\n  cumulativeGasUsed: string;\n  gasUsed: string;\n  isError: string;\n  txreceipt_status: string;\n  input: string;\n  contractAddress: string;\n  confirmations: string;\n  tokenDecimal: string;\n  tokenSymbol: string;\n  tokenID: string;\n  tokenName: string;\n}\n\n/**\n * @type TransactionConfig\n *\n * Transaction controller configuration\n * @property netWorkType - Polling interval used to fetch new currency rate\n * @property provider - Provider used to create a new underlying EthQuery instance\n * @property sign - Method used to sign transactions\n */\nexport interface TransactionConfig extends IConfig {\n  chainId: string;\n  netWorkType: string;\n}\n\n/**\n * @type TransactionState\n *\n * Transaction service state\n * @property transactions - A list of Transaction objects\n */\nexport interface TransactionState extends IState {\n  transactions: TransactionData[];\n}\n\n/**\n * Make TransactionData type data\n * @param data From Polygon get data\n * @param chainId Network type of desired network\n * @returns TransactionData type data\n */\nconst normalizeNftTx = (data: PolygonScanTransaction, chainId: string): TransactionData => {\n  const { timeStamp, blockNumber, to, from, hash } = data;\n  const time = parseInt(timeStamp, 10) * 1000;\n  return {\n    chainId,\n    status: 'confirmed',\n    time,\n    from,\n    to,\n    transactionHash: hash,\n    blockNumber,\n  };\n};\n\n/**\n * Return a URL that can be used to fetch ETH transactions.\n *\n * @param networkType - Network type of desired network.\n * @param urlParams - The parameters used to construct the URL.\n * @returns URL to fetch the access the endpoint.\n */\nconst getPolygonscanApiUrl = (\n  networkType: string,\n  urlParams: { [key: string]: string | undefined }\n): string => {\n  let polygonscanSubdomain = 'api';\n\n  if (networkType !== POLYGON) {\n    polygonscanSubdomain = `api-testnet`;\n  }\n\n  const apiUrl = `https://${polygonscanSubdomain}.polygonscan.com`;\n  let url = `${apiUrl}/api?`;\n\n  for (const paramKey in urlParams) {\n    if (urlParams[paramKey]) {\n      url += `${paramKey}=${urlParams[paramKey]}&`;\n    }\n  }\n  url += 'tag=latest&page=1';\n  return url;\n};\n\n/**\n * Execute fetch and return object response.\n *\n * @param request - The request information.\n * @param options - The fetch options.\n * @returns The fetch response JSON data.\n */\nconst nftAllFetch = async (request: string, options?: RequestInit) => {\n  const response = await fetch(request, options);\n  if (!response.ok) {\n    throw new Error(`Fetch failed with status '${response.status}' for request '${request}'`);\n  }\n  const object = await response.json();\n  return object;\n};\n\n/**\n * Handles the fetch of incoming transactions for polygonScan.\n *\n * @param networkType - Network type of desired network.\n * @param address - Address to get the transactions from.\n * @param txHistoryLimit - The maximum number of transactions to fetch.\n * @param opt - Object that can contain fromBlock and PolygonScan service API key.\n * @returns Responses for both ERC721 and ERC1155 token transactions.\n */\nconst handleNftTransactionFetchForPolygonscan = async (\n  networkType: string,\n  address: string,\n  opt?: FetchNftAllOptions\n): Promise<[{ [result: string]: [] }, { [result: string]: [] }]> => {\n  const urlParams = {\n    module: 'account',\n    address,\n    startBlock: opt?.fromBlockNum,\n    apikey: opt?.apiKey,\n    order: 'desc',\n  };\n  // 1155tx\n  const polygonscanToken1155TxUrl = getPolygonscanApiUrl(networkType, {\n    ...urlParams,\n    action: 'token1155tx',\n  });\n  const polygonscanToken1155TxResponsePromise = nftAllFetch(polygonscanToken1155TxUrl);\n\n  // nfttx\n  const polygonscanTokenNftUrl = getPolygonscanApiUrl(networkType, {\n    ...urlParams,\n    action: 'tokennfttx',\n  });\n  const polygonscanTokenNftResponsePromise = nftAllFetch(polygonscanTokenNftUrl);\n\n  let [polygonscanToken1155TxResponse, polygonscanTokenNftResponse] = await Promise.all([\n    polygonscanToken1155TxResponsePromise,\n    polygonscanTokenNftResponsePromise,\n  ]);\n\n  if (\n    polygonscanToken1155TxResponse.status === '0' ||\n    polygonscanToken1155TxResponse.result.length <= 0\n  ) {\n    polygonscanToken1155TxResponse = {\n      status: polygonscanToken1155TxResponse.status,\n      result: [],\n    };\n  }\n\n  if (\n    polygonscanTokenNftResponse.status === '0' ||\n    polygonscanTokenNftResponse.result.length <= 0\n  ) {\n    polygonscanTokenNftResponse = {\n      status: polygonscanTokenNftResponse.status,\n      result: [],\n    };\n  }\n\n  return [polygonscanToken1155TxResponse, polygonscanTokenNftResponse];\n};\n/**\n * Service responsible for submitting and managing transactions\n */\nexport class TransactionService<\n  A extends AbstractAdapter<TransactionState, TransactionConfig>\n> extends AbstractService<A, TransactionState, TransactionConfig> {\n  /**\n   * Name of this service used during composition\n   */\n\n  override name = 'TransactionService';\n\n  initialize(): void {}\n\n  /**\n   * Get transactions from Etherscan Or Polygon for the given address. By default all transactions are\n   * returned, but the `fromBlock` option can be given to filter just for transactions from a\n   * specific block onward.\n   *\n   * @param address - The address to fetch the transactions for.\n   * @param opt - Object containing optional data, fromBlock and Etherscan Or Polygon API key.\n   * @returns The block number of the latest incoming transaction.\n   */\n  async fetchNftAll(address: string, opt?: FetchNftAllOptions): Promise<string | void> {\n    const type = this.adapter?.configure().netWorkType;\n    const chainId = this.adapter?.configure().chainId;\n    let latestIncomingTxBlockNumber = '';\n    if (type && chainId) {\n      // polygon\n      const transactionFetchResult = await handleNftTransactionFetchForPolygonscan(\n        type,\n        address,\n        opt\n      );\n\n      const [scanToken1155TxResponse, scanTokenNftResponse] = transactionFetchResult;\n\n      const normalizedToken1155Txs = scanToken1155TxResponse.result.map(\n        (data: PolygonScanTransaction) => normalizeNftTx(data, chainId)\n      );\n      const normalizedTokenNftTxs = scanTokenNftResponse.result.map(\n        (data: PolygonScanTransaction) => normalizeNftTx(data, chainId)\n      );\n\n      const allTransaction: TransactionData[] = [\n        ...normalizedToken1155Txs,\n        ...normalizedTokenNftTxs,\n      ];\n\n      allTransaction.sort((a, b) => (a.time < b.time ? -1 : 1));\n\n      allTransaction.forEach(async (data) => {\n        /* istanbul ignore next */\n        if (\n          data.chainId === chainId &&\n          data.to &&\n          data.to.toLowerCase() === address.toLowerCase()\n        ) {\n          if (\n            data.blockNumber &&\n            (!latestIncomingTxBlockNumber ||\n              parseInt(latestIncomingTxBlockNumber, 10) < parseInt(data.blockNumber, 10))\n          ) {\n            latestIncomingTxBlockNumber = data.blockNumber;\n          }\n        }\n      });\n\n      this.updateState({ transactions: allTransaction });\n    }\n\n    return latestIncomingTxBlockNumber;\n  }\n}\n\nexport default TransactionService;\n"]}